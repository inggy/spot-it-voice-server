{"version":3,"sources":["components/JoinGameForm.tsx","scenes/SceneManager.ts","scenes/Scene.ts","pixi/Button.ts","models/GameActions.tsx","schemas/SubscriptionManager.ts","schemas/selectors/LobbySelectors.ts","pixi/StyleConstants.ts","scenes/LobbyScene.ts","schemas/selectors/GameSelectors.ts","pixi/PlayerList.ts","pixi/SpriteUtil.ts","pixi/CardContainer.ts","pixi/DeckContainer.ts","pixi/HandContainer.ts","scenes/GameScene.ts","App.tsx","serviceWorker.ts","index.tsx","audio/MicManager.ts","audio/AudioUtils.ts"],"names":["JoinGameForm","props","useState","roomName","setRoomName","nickName","setNickName","micGranted","setMicGranted","onSubmit","e","preventDefault","handleSubmit","htmlFor","name","value","onChange","target","type","disabled","onClick","MicManager","getPermission","then","obtainedPermission","SceneManager","app","scenes","current","this","scene","currentScene","stage","removeChild","hasOwnProperty","nextScene","hasRun","init","addChild","Scene","room","PIXI","Button","text","style","textStyle","clickCallback","textSprite","graphics","buttonWidth","width","padding","buttonHeight","height","lineStyle","borderWidth","borderColor","beginFill","fillColor","drawRoundedRect","Math","floor","radius","endFill","x","y","interactive","buttonMode","on","enabled","alpha","sitDown","send","standUp","startGame","backToLobby","SchemaListeners","callbacks","callback","push","changes","forEach","schemaListenerMappings","WeakMap","SubscriptionManager","schema","set","get","invokeCallbacks","_onChangeHandler","curSchemaListeners","addListener","getHost","host","isHost","playerId","isPlayer","players","getPlayerName","TextStyles","fontFamily","fontSize","default","ButtonStyles","primary","LobbyScene","playerListContainer","spectatorListContainer","sitDownButton","HEADING_2","standUpButton","startGameButton","HEADING_1","GameActions","state","change","field","renderPlayerList","updateButtonStates","renderSpectatorList","playerHeader","renderer","spectatorsHeader","removeChildren","Object","values","user","index","id","spectators","isUserPlayer","sessionId","setEnabled","visible","getGamePhase","gameState","phase","getCenterCardIndex","centerCardIndex","getCenterCard","deck","isWinner","winner","getPlayerHandIndex","playerHandIndex","getPlayerCardsRemaining","curIndex","playerHand","getPlayerHand","length","hands","cards","getPlayerCardAtIndex","handIndex","cardIndex","getCandidateWords","result","Set","symbols","i","add","getWordForSymbolId","getPlayerCard","symbolId","ICON_WORDS","ICON_WORDS_TO_SYMBOL_ID","fromEntries","map","str","PlayerList","userId","playerTextMapping","playerScoreMapping","spotItSchema","numPrinted","keys","nameSprite","numCards","cardsLeft","hand","getCardsRemaining","cardRemainingSprite","onStateChange","SpriteUtil","spriteKey","window","__PUBLIC_URL__","getSpriteSheet","shared","resources","spritesheet","CardContainer","size","card","_clickCallback","disableOverlay","errorOverlay","drawCircle","sheet","angleBetweenSprites","PI","angleOffset","rotationOffset","distFromCenter","cardSprites","symbolNumber","fileName","padStart","sprite","textures","spriteSize","offset","cos","sin","scale","anchor","rotation","event","cardHintSprites","hintSprite","blurFilter","BlurFilter","filters","DeckContainer","curCard","playedByLabel","title","drawNewCard","playerPlayed","find","includes","getCenterCardPlayedBy","playedBy","destroy","children","HandContainer","playCardFunc","wrongPlayTimeout","playCardCallback","cardsRemainingLabel","_onLocalTimeoutChange","newFreeAfterTime","now","Date","clearTimeout","hideError","showError","setTimeout","currentTransciptionResultId","hasSubmiitedForCurrentTranscription","_handleWords","transcriptionResult","console","log","words","toString","resultId","candidateWords","submittableWord","w","has","subscribeClick","cardSymbol","numRemaining","clear","updateCardsRemaining","_unsubscribeFromPlayerDataChange","endTranscription","disable","_subscribeToPlayerDataChange","beginTranscription","transcribeUrls","handPlayerId","localTimeouts","GameScene","toLobbyButton","getReadyLabel","handContainer","deckContainer","effectivePlayerId","gameInitialized","playerList","symbol","localTime","reset","handleGamePhaseChange","isAPlayer","prepareForGame","newGamePhase","initializeDecks","showHandLabel","endGameAsWinner","winningPlayer","endGame","location","document","replace","endpoint","indexOf","protocol","port","client","Colyseus","App","gameContainer","useRef","pixiReady","setPixiReady","pixiApp","setPixiApp","inRoom","setInRoom","useEffect","load","backgroundColor","prepend","view","className","joinOrCreate","sceneManager","addScene","header","getCurrentScene","switch","ref","Boolean","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message","micStream","inputSampleRate","socket","eventStreamMarshaller","EventStreamMarshaller","util_utf8_node","streamAudioToWebSocket","userMediaStream","websocketUrl","playRecording","MicrophoneStream","data","sampleRate","setStream","WebSocket","binaryType","onopen","rawAudioChunk","binary","audioChunk","raw","toRaw","downsampledBuffer","audioUtils","pcmEncodedBuffer","audioEventMessage","buffer","Buffer","from","headers","body","marshall","convertAudioToBinaryMessage","readyState","OPEN","onmessage","messageWrapper","unmarshall","messageBody","JSON","parse","String","fromCharCode","apply","handleEventStreamMessage","Message","stop","onerror","onclose","closeEvent","pauseRecording","wireSocketEvents","close","messageJson","results","Transcript","Results","Alternatives","decodeURIComponent","escape","toLowerCase","split","ResultId","Promise","resolve","reject","getUserMedia","video","audio","stream","alert","pcmEncode","input","ArrayBuffer","DataView","s","max","min","setInt16","downsampleBuffer","outputSampleRate","sampleRateRatio","newLength","round","Float32Array","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count"],"mappings":"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","file":"static/js/main.7a3fda24.chunk.js","sourcesContent":["import React, {useState} from \"react\";\nimport MicManager from \"../audio/MicManager\";\n\ninterface Props {\n    handleSubmit(roomName: string, name: string): void;\n}\n\nexport const JoinGameForm: React.FC<Props> = (props) => {\n    const [roomName, setRoomName] = useState<string>(\"\");\n    const [nickName, setNickName] = useState<string>(\"\");\n    const [micGranted, setMicGranted] = useState<boolean>(false);\n\n    function getAudio() {\n        MicManager.getPermission().then(obtainedPermission => setMicGranted(obtainedPermission));\n    }\n\n    return (\n        <div>\n            <form onSubmit={(e) => {\n                    e.preventDefault();\n                    props.handleSubmit(roomName, nickName);\n                    return false;\n                }}>\n                <label htmlFor=\"roomName\">Room name</label>\n                <input name=\"roomName\" value={roomName} onChange={e => setRoomName(e.target.value)} />\n                <label htmlFor=\"nickName\">Your name</label>\n                <input name=\"nickName\" value={nickName} onChange={e => setNickName(e.target.value)} />\n                \n                {micGranted && <button type=\"submit\" disabled={roomName === \"\" || nickName === \"\"}>Join</button>}\n            </form>\n            {!micGranted && <button onClick={getAudio}>Grant Microphone Permission</button>}\n        </div>\n    );\n}","import { IScene } from \"./Scene\";\n\nexport class SceneManager {\n    private app: PIXI.Application;\n    private scenes: Record<string, IScene>;\n    private current: string = \"\";\n\n    constructor(app: PIXI.Application) {\n        this.app = app;\n        this.scenes = {};\n    }\n\n    public getCurrentScene(): string {\n        return this.current;\n    }\n\n    public addScene(name: string, scene: IScene): void {\n        this.scenes[name] = scene;\n    }\n\n    public switch(name: string) {\n        const currentScene = this.scenes[this.current];\n        if (currentScene) {\n            this.app.stage.removeChild(currentScene);\n        }\n\n        if (this.scenes.hasOwnProperty(name)) {\n            this.current = name;\n            const nextScene = this.scenes[name];\n            if (nextScene) {\n                if (!nextScene.hasRun) {\n                    nextScene.init();\n                    nextScene.hasRun = true;\n                }\n                this.app.stage.addChild(nextScene);\n            }\n        }\n    }\n}","import * as PIXI from \"pixi.js\";\nimport * as Colyseus from \"colyseus.js\";\nimport { SpotItSchema } from \"../schemas/SpotItSchema\";\n\nexport interface IScene extends PIXI.Container {\n    app: PIXI.Application;\n    hasRun: boolean;\n    init(): void;\n}\n\nexport class Scene extends PIXI.Container implements IScene {\n    public app: PIXI.Application;\n    public hasRun: boolean = false;\n    public room: Colyseus.Room<SpotItSchema>;\n\n    constructor(app: PIXI.Application, room: Colyseus.Room<SpotItSchema>) {\n        super();\n        this.app = app;\n        this.room = room;\n    }\n\n    public init() : void {};\n\n}","import * as PIXI from \"pixi.js\";\n\nexport type ButtonStyle = {\n    padding: number,\n    borderWidth: number,\n    radius: number\n    borderColor: number,\n    fillColor: number;\n};\n\nexport type ClickCallback = () => any;\n\nexport class Button extends PIXI.Container {\n    clickCallback: ClickCallback | null = null;\n\n    constructor(text: string, style: ButtonStyle, textStyle: PIXI.TextStyle) {\n        super();\n        const textSprite = new PIXI.Text(text, textStyle);\n        \n        const graphics = new PIXI.Graphics();\n\n        const buttonWidth = textSprite.width + 2 * style.padding;\n        const buttonHeight = textSprite.height + 2 * style.padding;\n        graphics.lineStyle(style.borderWidth, style.borderColor, 1, 0);\n        graphics.beginFill(style.fillColor);\n        graphics.drawRoundedRect(Math.floor(-(buttonWidth/2)), 0, buttonWidth, buttonHeight, style.radius);\n        graphics.endFill();\n        \n        textSprite.x = Math.floor(-(textSprite.width/2));\n        textSprite.y = Math.floor(style.padding);\n        this.addChild(graphics);\n        this.addChild(textSprite);\n\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on(\"pointerdown\", () => {\n            if (this.clickCallback) {\n                this.clickCallback();\n            }\n        })\n        \n    }\n\n    onClick(clickCallback: ClickCallback) {\n        this.clickCallback = clickCallback;\n    }\n\n    setEnabled(enabled: boolean) {\n        if (enabled) {\n            this.interactive = true;\n            this.buttonMode = true;\n            this.alpha = 1;\n        } else {\n            this.interactive = false;\n            this.buttonMode = false;\n            this.alpha = 0.5;\n        }\n    }\n}","import * as Colyseus from \"colyseus.js\";\n\nimport { SpotItSchema } from \"../schemas/SpotItSchema\";\n\nexport function sitDown(room: Colyseus.Room<SpotItSchema> ) {\n    room.send(\"sitDown\");\n}\n\nexport function standUp(room: Colyseus.Room<SpotItSchema> ) {\n    room.send(\"standUp\");\n}\n\nexport function startGame(room: Colyseus.Room<SpotItSchema>) {\n    room.send(\"startGame\");\n}\n\nexport function selectSymbol(room: Colyseus.Room<SpotItSchema>, symbol: number, centerCardIndex: number) {\n    room.send(\"selectSymbol\", { symbol, centerCardIndex, localTime: Date.now() });\n}\n\nexport function backToLobby(room: Colyseus.Room<SpotItSchema>) {\n    room.send(\"returnLobby\");\n}","import { Schema, DataChange } from \"@colyseus/schema\";\n\ntype Listener = (changes: DataChange[]) => any;\n\nclass SchemaListeners {\n    private callbacks: Listener[] = [];\n\n    public addListener(callback: Listener) {\n        this.callbacks.push(callback);\n    }\n\n    public invokeCallbacks(changes: DataChange[]) {\n        this.callbacks.forEach(callback => callback(changes));\n    }\n}\n\nconst schemaListenerMappings = new WeakMap<Object, SchemaListeners>();\n\nfunction _onChangeHandler(schema: Schema, changes: DataChange[]) {\n    schemaListenerMappings.get(schema)?.invokeCallbacks(changes);\n}\n\nexport const SubscriptionManager = {\n    subscribe(schema: Schema, callback: Listener) {\n        \n        if (!schema.onChange) {\n            schemaListenerMappings.set(schema, new SchemaListeners());\n            schema.onChange = (changes) => _onChangeHandler(schema, changes);\n        }\n\n        let curSchemaListeners = schemaListenerMappings.get(schema);\n        if (curSchemaListeners) {\n            curSchemaListeners.addListener(callback);\n        }\n    }\n}","import { SpotItSchema } from \"../SpotItSchema\";\nimport { User } from \"../User\";\n\nexport function getHost(schema: SpotItSchema): string {\n    return schema.host;\n}\n\nexport function isHost(schema: SpotItSchema, playerId: string): boolean {\n    return getHost(schema) === playerId;\n}\n\nexport function getPlayerList(schema: SpotItSchema): User[] {\n    return Object.values(schema.players);\n}\n\nexport function getSpectatorList(schema: SpotItSchema): User[] {\n    return Object.values(schema.spectators);\n}\n\nexport function isPlayer(schema: SpotItSchema, playerId: string): boolean {\n    return !!schema.players[playerId];\n}\n\nexport function getPlayerName(schema: SpotItSchema, playerId: string) {\n    return schema.players[playerId].name;\n}","import * as PIXI from \"pixi.js\";\nimport { ButtonStyle } from \"./Button\";\n\nconst APP_FONT_FAMILY = \"Comic Sans MS\";\n\nexport const TextStyles: Record<string, PIXI.TextStyle> = {\n    \"HEADING_1\": new PIXI.TextStyle({\n        fontFamily: APP_FONT_FAMILY,\n        fontSize: 36,\n    }),\n    \"HEADING_2\": new PIXI.TextStyle({\n        fontFamily: APP_FONT_FAMILY,\n        fontSize: 24,\n    }),\n    default: new PIXI.TextStyle({\n        fontFamily: APP_FONT_FAMILY,\n        fontSize: 16,\n    })\n};\n\nconst PADDING = 10;\nconst RADIUS = 8;\n\nexport const ButtonStyles: Record<string, ButtonStyle> = {\n    default: {\n        padding: PADDING,\n        borderColor: 0x000000,\n        borderWidth: 3,\n        fillColor: 0xffffff,\n        radius: RADIUS,\n    },\n    primary: {\n        padding: PADDING,\n        borderColor: 0x000000,\n        borderWidth: 3,\n        fillColor: 0x35CC5A,\n        radius: RADIUS,\n    }\n}\n","import * as PIXI from \"pixi.js\";\nimport { DataChange } from \"@colyseus/schema\";\n\nimport { Scene } from \"./Scene\";\nimport { User } from \"../schemas/User\";\nimport { Button } from \"../pixi/Button\";\nimport * as GameActions from \"../models/GameActions\";\nimport { SubscriptionManager } from \"../schemas/SubscriptionManager\";\nimport { isHost, getPlayerList, getSpectatorList, isPlayer } from \"../schemas/selectors/LobbySelectors\";\nimport { TextStyles, ButtonStyles } from \"../pixi/StyleConstants\";\n\nexport class LobbyScene extends Scene {\n    private playerListContainer: PIXI.Container = new PIXI.Container();\n    private spectatorListContainer: PIXI.Container = new PIXI.Container();\n    private sitDownButton: Button = new Button(\"Play\", ButtonStyles.default, TextStyles.HEADING_2);\n    private standUpButton: Button = new Button(\"Spectate\", ButtonStyles.default, TextStyles.HEADING_2)\n    private startGameButton: Button = new Button(\"Start Game\", ButtonStyles.primary, TextStyles.HEADING_1);\n\n    init() {\n        SubscriptionManager.subscribe(this.room.state, (changes: DataChange[]) => {\n            changes.forEach(change => {\n                switch (change.field) {\n                    case \"host\":\n                    case \"players\":\n                        this.renderPlayerList();\n                        this.updateButtonStates();\n                        break;\n                    case \"spectators\":\n                        this.renderSpectatorList();\n                        break;\n                    default:\n                        break;\n                }\n            });\n        });\n        \n        const playerHeader = new PIXI.Text(`Players`, TextStyles.HEADING_1);\n        playerHeader.x = (this.app.renderer.width * 1.0 / 3.0) - (playerHeader.width / 2);\n        playerHeader.y = 100;\n        this.addChild(playerHeader);\n\n        const spectatorsHeader = new PIXI.Text(`Spectators`, TextStyles.HEADING_1);\n        spectatorsHeader.x = (this.app.renderer.width * 2.0 / 3.0) - (spectatorsHeader.width / 2);\n        spectatorsHeader.y = 100;\n        this.addChild(spectatorsHeader);\n\n        this.playerListContainer.x = playerHeader.x + (playerHeader.width /2);\n        this.playerListContainer.y = playerHeader.y + playerHeader.height + 15;\n        this.addChild(this.playerListContainer);\n        \n        this.spectatorListContainer.x = spectatorsHeader.x + (spectatorsHeader.width/2);\n        this.spectatorListContainer.y = this.playerListContainer.y;\n        this.addChild(this.spectatorListContainer);\n        \n        this.renderPlayerList();\n        this.renderSpectatorList();\n\n        this.sitDownButton.x = Math.floor((this.app.renderer.width /2));\n        this.sitDownButton.y = 470;\n        this.sitDownButton.onClick(this.sitDown);\n\n        this.standUpButton.x = Math.floor((this.app.renderer.width /2));\n        this.standUpButton.y = 470;\n        this.standUpButton.onClick(this.standUp);\n\n        this.startGameButton.x = Math.floor((this.app.renderer.width /2));\n        this.startGameButton.y = 530;\n        this.startGameButton.onClick(this.startGame);\n\n        this.addChild(\n            this.sitDownButton,\n            this.standUpButton\n        );\n\n        this.updateButtonStates();\n    }\n\n    renderPlayerList() {\n        this.playerListContainer.removeChildren();\n\n        getPlayerList(this.room.state).forEach((user: User, index: number) => {\n            const textSprite = new PIXI.Text(user.name + (isHost(this.room.state, user.id) ? \" [Host]\" : \"\"), TextStyles.HEADING_2 );\n            textSprite.x = -(textSprite.width /2);\n            textSprite.y = index * 30;\n            this.playerListContainer.addChild(textSprite);\n        });\n    }\n\n    renderSpectatorList() {\n        this.spectatorListContainer.removeChildren();\n\n        getSpectatorList(this.room.state).forEach((user: User, index: number) => {\n            const textSprite = new PIXI.Text(user.name, TextStyles.HEADING_2);\n            textSprite.x = -(textSprite.width /2);\n            textSprite.y = index * 30;\n            this.spectatorListContainer.addChild(textSprite);\n        });\n    }\n\n    updateButtonStates() {\n        const isUserPlayer = isPlayer(this.room.state, this.room.sessionId);\n\n        this.sitDownButton.setEnabled(!isUserPlayer);\n        this.sitDownButton.visible = !isUserPlayer;\n        this.standUpButton.setEnabled(isUserPlayer);\n        this.standUpButton.visible = isUserPlayer;\n\n        if (isHost(this.room.state, this.room.sessionId)) {\n            this.addChild(this.startGameButton);\n        } else {\n            this.removeChild(this.startGameButton);\n        }\n    }\n\n    sitDown = () => {\n        GameActions.sitDown(this.room);\n    }\n\n    standUp = () =>  {\n        GameActions.standUp(this.room);\n    }\n\n    startGame = () => {\n        GameActions.startGame(this.room);\n    }\n}","import { SpotItSchema } from \"../SpotItSchema\";\nimport { Card } from \"../Card\";\nimport { Hand } from \"../Hand\";\nimport { getPlayerName } from \"./LobbySelectors\";\n\n\nexport function getGamePhase(schema: SpotItSchema): string {\n    return schema.gameState.phase;\n}\n\nexport function hasGameEnded(schema: SpotItSchema): boolean {\n    return getGamePhase(schema) === \"endgame\";\n}\n\nexport function getCenterCardIndex(schema: SpotItSchema): number {\n    return schema.gameState.centerCardIndex;\n}\n\nexport function getCenterCard(schema: SpotItSchema): Card {\n    return schema.deck[getCenterCardIndex(schema)];\n}\n\nexport function isWinner(schema: SpotItSchema, playerId: string): boolean {\n    return schema.gameState.winner === playerId;\n}\n\nexport function getWinnerName(schema: SpotItSchema): string {\n    return getPlayerName(schema, schema.gameState.winner);\n}\n\nexport function getPlayerHandIndex(schema: SpotItSchema, playerId: string): number {\n    return schema.gameState.playerHandIndex[playerId];\n}\n\nexport function getPlayerCardsRemaining(schema: SpotItSchema, playerId: string, curIndex: number): number | null {\n    const playerHand = getPlayerHand(schema, playerId);\n    if (playerHand) {\n        return playerHand.length - curIndex;\n    } else {\n        return null;\n    }\n}\n\nfunction getPlayerHand(schema: SpotItSchema, playerId: string): number[] {\n    return (schema.gameState.hands[playerId] as Hand)?.cards;\n}\n\nexport function getPlayerCard(schema: SpotItSchema, playerId: string): Card {\n    const cardIndex = getPlayerHand(schema, playerId)[getPlayerHandIndex(schema, playerId)];\n    return schema.deck[cardIndex]\n}\n\nexport function getPlayerCardAtIndex(schema: SpotItSchema, playerId: string, handIndex: number) {\n    const cardIndex = getPlayerHand(schema, playerId)[handIndex];\n    return schema.deck[cardIndex]\n}\n\nexport function getCardsRemaining(schema: SpotItSchema, playerId: string): number {\n    if (isWinner(schema, playerId)) {\n        return 0;\n    }\n    \n\n    const curIndex = getPlayerHandIndex(schema, playerId);\n    const hand = getPlayerHand(schema, playerId);\n\n    if (curIndex == null || !hand) {\n        return 0\n    }\n    \n    return hand.length - curIndex;\n}\n\nexport function getCenterCardPlayedBy(schema: SpotItSchema): string | null {\n\n    const centerCardIndex = getCenterCardIndex(schema);\n    \n    const playerPlayed = Object.keys(schema.gameState.hands).find(playerId => {\n        const playerHand = getPlayerHand(schema, playerId);\n        return playerHand.includes(centerCardIndex);\n    });\n    \n    if (playerPlayed) {\n        return getPlayerName(schema, playerPlayed);\n    } else {\n        return null;\n    }\n}\n\nexport function getTranscribeUrl(schema: SpotItSchema, playerId: string): string {\n    return schema.gameState.transcribeUrls[playerId];\n}\n\nexport function getCandidateWords(schema:SpotItSchema, playerId: string): Set<string> {\n    const result = new Set<string>();\n    getCenterCard(schema)\n        .symbols\n        .forEach(i => result.add(getWordForSymbolId(i)))\n\n    getPlayerCard(schema, playerId)\n        .symbols\n        .forEach(i => result.add(getWordForSymbolId(i)))\n    return result;\n}\n\nexport function getSymbolIdFromWord(word: string): number {\n    return ICON_WORDS_TO_SYMBOL_ID[word];\n}\n\nexport function getWordForSymbolId(symbolId: number) {\n    return ICON_WORDS[symbolId - 1];\n}\n\nconst ICON_WORDS = [\n    \"flower\",\n    \"gorilla\",\n    \"eggplant\",\n    \"moon\",\n    \"monkey\",\n    \"snowman\",\n    \"water\",\n    \"fire\",\n    \"heart\",\n    \"camera\",\n    \"sparkle\",\n    \"raccoon\",\n    \"unicorn\",\n    \"puzzle\",\n    \"sloth\",\n    \"bird\",\n    \"snake\",\n    \"soccer\",\n    \"bee\",\n    \"palette\",\n    \"clover\",\n    \"canada\",\n    \"rain\",\n    \"lightning\",\n    \"tornado\",\n    \"umbrella\",\n    \"wave\",\n    \"cake\",\n    \"snow\",\n    \"bacon\",\n    \"clown\",\n    \"poop\",\n    \"robot\",\n    \"nails\",\n    \"leg\",\n    \"santa\",\n    \"bell\",\n    \"drum\",\n    \"castle\",\n    \"covid\",\n    \"sob\",\n    \"genie\",\n    \"train\",\n    \"hat\",\n    \"purse\",\n    \"peach\",\n    \"pretzle\",\n    \"dumpling\",\n    \"martini\",\n    \"taxi\",\n    \"thread\",\n    \"boat\",\n    \"cash\",\n    \"trash\",\n    \"couch\",\n    \"saturn\",\n    \"ticket\"\n];\n\nconst ICON_WORDS_TO_SYMBOL_ID: Record<string, number> = Object.fromEntries(ICON_WORDS.map((str, i) => ([str, i+1])));","import * as PIXI from 'pixi.js'\nimport * as Colyseus from 'colyseus.js';\n\nimport { SpotItSchema } from \"../schemas/SpotItSchema\";\nimport { getCardsRemaining } from '../schemas/selectors/GameSelectors';\nimport { TextStyles } from './StyleConstants';\n\nexport class PlayerList extends PIXI.Container {\n    private playerTextMapping: Record<string, PIXI.Text> = {};\n    private playerScoreMapping: Record<string, PIXI.Text> = {};\n\n    constructor(userId: string, room: Colyseus.Room<SpotItSchema>) {\n        super();\n        \n        // TODO: make this more specific\n        room.onStateChange(this.renderPlayerList)\n\n        this.renderPlayerList(room.state);\n    }\n\n    renderPlayerList = (spotItSchema: SpotItSchema) => {\n        this.removeChildren();\n        this.playerTextMapping = {};\n        this.playerScoreMapping = {};\n\n        let numPrinted = 0;\n\n        Object.keys(spotItSchema.players).forEach((playerId) => {\n            const nameSprite = new PIXI.Text(spotItSchema.players[playerId].name, TextStyles.HEADING_2);\n            nameSprite.x = 0;\n            nameSprite.y = numPrinted * 65;\n            this.addChild(nameSprite);\n            this.playerTextMapping[playerId] = nameSprite;\n\n            const cardsLeft = getCardsRemaining(spotItSchema, playerId);\n            const cardRemainingSprite = new PIXI.Text(formatCardsRemaining(cardsLeft), TextStyles.HEADING_2);\n            cardRemainingSprite.x = 20;\n            cardRemainingSprite.y = nameSprite.y + 30;\n            this.addChild(cardRemainingSprite);\n            this.playerScoreMapping[playerId] = cardRemainingSprite;\n\n            numPrinted++;\n            \n        });\n    }\n\n}\n\nfunction formatCardsRemaining(numCards: number) {\n    return `${numCards} card${numCards > 1 ? \"s\":\"\"}`;\n}","import * as PIXI from \"pixi.js\";\n\nexport const SpriteUtil = {\n    spriteKey: (window as any).__PUBLIC_URL__ + \"/assets/spritesheet.json\",\n\n    getSpriteSheet: (): PIXI.Spritesheet => {\n        return PIXI.Loader.shared.resources[SpriteUtil.spriteKey].spritesheet as PIXI.Spritesheet;\n    }\n}","import { Card } from \"../schemas/Card\";\nimport * as PIXI from 'pixi.js';\nimport { SpriteUtil } from \"./SpriteUtil\";\nimport { TextStyles } from \"./StyleConstants\";\nimport { getWordForSymbolId } from \"../schemas/selectors/GameSelectors\";\n\ntype ClickCallback = (symbol: number) => void;\n\nexport class CardContainer extends PIXI.Container {\n    private _clickCallback: ClickCallback[] = [];\n    private disableOverlay: PIXI.Graphics = new PIXI.Graphics();\n    private errorOverlay: PIXI.Graphics = new PIXI.Graphics();\n\n    constructor(size: number, card: Card, interactive: boolean = false) {\n        super();\n\n        const graphics = new PIXI.Graphics();\n\n        graphics.lineStyle(2, 0x999999, 1);\n        graphics.beginFill(0xFFFFFF, 1);\n        graphics.drawCircle(0, 0, size / 2);\n        graphics.endFill();\n\n        this.addChild(graphics);\n        \n        this.disableOverlay.beginFill(0xffffff, 0.5);\n        this.disableOverlay.drawCircle(0, 0, size / 2);\n        this.disableOverlay.endFill();\n\n        \n        this.errorOverlay.lineStyle(4, 0xe30000, 1);\n        this.errorOverlay.drawCircle(0, 0, size / 2);\n        \n        let sheet = SpriteUtil.getSpriteSheet();\n        \n        const angleBetweenSprites = (Math.PI * 2) / (card.symbols.length - 1);\n        const angleOffset = card.rotationOffset * (Math.PI * 2);\n\n        const distFromCenter = size/3.75;\n\n        const cardSprites = card.symbols.map((symbolNumber, index) => {\n            const fileName = (symbolNumber + \"\").padStart(2, \"0\") + \".png\";\n            const sprite = new PIXI.Sprite(sheet.textures[fileName]);\n            \n            const spriteSize = size / 4;\n            const x = (index === 0) ? 0 : (distFromCenter + (size / 9.0  * card.offset[index])) * Math.cos(angleOffset + (index * angleBetweenSprites));\n            const y = (index === 0) ? 0 : (distFromCenter + (size / 9.0  * card.offset[index])) * Math.sin(angleOffset + (index * angleBetweenSprites));\n           \n            sprite.x = x;\n            sprite.y = y;\n            \n            sprite.width = spriteSize * (card.scale[index]);\n            sprite.height = spriteSize * (card.scale[index]);\n            sprite.anchor.set(0.5);\n            sprite.rotation = card.rotation[index] * (Math.PI * 2);\n            \n            if (interactive) {\n                sprite.interactive = true;\n                sprite.buttonMode = true;\n                sprite.on('pointerdown', (event: PIXI.InteractionEvent) => {\n                    this._clickCallback.forEach(callback => callback(symbolNumber));\n                });\n            }\n \n            return sprite;\n        });\n        const cardHintSprites = card.symbols.map((symbolNumber, index) => {\n            const hintSprite = new PIXI.Text(symbolNumber + \" \" + getWordForSymbolId(symbolNumber));\n\n            const x = (index === 0) ? 0 : (distFromCenter + (size / 9.0  * card.offset[index])) * Math.cos(angleOffset + (index * angleBetweenSprites));\n            const y = (index === 0) ? 0 : (distFromCenter + (size / 9.0  * card.offset[index])) * Math.sin(angleOffset + (index * angleBetweenSprites));\n\n            hintSprite.x = x;\n            hintSprite.y = y;\n\n            return hintSprite;\n        })\n        \n        this.addChild(...cardSprites);\n        this.addChild(...cardHintSprites);\n\n        //const cardId = new PIXI.Text(card.id + \"\");\n        //this.addChild(cardId);\n    }\n\n    disable() {\n        this.removeChild(this.errorOverlay);\n        const blurFilter = new PIXI.filters.BlurFilter(5);\n        this.filters = [blurFilter];\n        this.addChild(this.disableOverlay);\n    }\n\n    showError() {\n        this.addChild(this.errorOverlay);\n    }\n\n    hideError() {\n        this.removeChild(this.errorOverlay);\n    }\n\n    clear() {\n        this.filters = [];\n        this.removeChildren();\n    }\n\n    subscribeClick(callback: ClickCallback) {\n        this._clickCallback.push(callback);\n    }\n}","import * as PIXI from \"pixi.js\";\nimport { Card } from \"../schemas/Card\";\nimport { SpotItSchema } from \"../schemas/SpotItSchema\";\nimport { CardContainer } from \"./CardContainer\";\nimport { SubscriptionManager } from \"../schemas/SubscriptionManager\";\nimport { getCenterCard, getCenterCardPlayedBy } from \"../schemas/selectors/GameSelectors\";\nimport { TextStyles } from \"./StyleConstants\";\n\nexport class DeckContainer extends PIXI.Container {\n    private curCard: CardContainer | null = null;\n    private size: number = 0;\n    private schema: SpotItSchema;\n    private playedByLabel: PIXI.Text;\n\n    constructor(spotItSchema: SpotItSchema, size: number) {\n        super();\n\n        this.schema = spotItSchema;\n        this.size = size;\n        \n        const title = new PIXI.Text(\"Center Card\", TextStyles.HEADING_1);\n        title.x = -Math.floor(title.width / 2);\n        title.y = -(Math.floor(this.size / 2) + 85);\n\n        this.playedByLabel = new PIXI.Text(\"\", TextStyles.HEADING_2);\n        this.playedByLabel.y = -(Math.floor(this.size / 2) + 40);\n\n        SubscriptionManager.subscribe(spotItSchema.gameState, (changes) => {\n            changes.forEach(change => {\n                if (change.field === \"centerCardIndex\") {\n                    this.drawNewCard(getCenterCard(spotItSchema), getCenterCardPlayedBy(spotItSchema));\n                }\n            })\n        });\n\n        this.drawNewCard(getCenterCard(spotItSchema), null);\n        this.addChild(title);\n        this.addChild(this.playedByLabel);\n    }\n\n    drawNewCard(card: Card, playedBy: string | null) {\n        if (this.curCard) {\n            this.removeChild(this.curCard);\n            this.curCard.destroy({children: true});\n        }\n\n        if (playedBy) {\n            this.playedByLabel.text = `played by ${playedBy}`;\n            this.playedByLabel.x = -Math.floor((this.playedByLabel.width / 2));\n        } else {\n            this.playedByLabel.text = \"\";\n        }\n        this.curCard = new CardContainer(this.size, card);\n        this.addChild(this.curCard);\n    }\n\n    reset() {\n        if (this.curCard) {\n            this.removeChild(this.curCard);\n        }\n        this.curCard = null;\n    }\n\n    prepareForGame() {\n        this.drawNewCard(getCenterCard(this.schema), null);\n    }\n}","import * as PIXI from \"pixi.js\";\nimport { Card } from \"../schemas/Card\";\nimport { SpotItSchema } from \"../schemas/SpotItSchema\";\nimport { CardContainer } from \"./CardContainer\";\nimport { getPlayerCardAtIndex, getPlayerCardsRemaining, getTranscribeUrl, getCandidateWords, getSymbolIdFromWord } from \"../schemas/selectors/GameSelectors\";\nimport { TextStyles } from \"./StyleConstants\";\nimport MicManager, { TranscriptionResult } from \"../audio/MicManager\";\n\nexport type PlayCardFunction = (symbol: number) => void;\n\nexport class HandContainer extends PIXI.Container {\n    private curCard: CardContainer | null = null;\n    private size: number = 0;\n    private playerId: string = \"\";\n    private isPlayer: boolean = true;\n\n    private wrongPlayTimeout: null | NodeJS.Timeout = null;\n\n    private playCardCallback: PlayCardFunction;\n\n    private schema: SpotItSchema;\n    private cardsRemainingLabel: PIXI.Text;\n\n    constructor(spotItSchema: SpotItSchema, size: number, playCardFunc: PlayCardFunction) {\n        super();\n\n        this.playCardCallback = playCardFunc;\n\n        this.schema = spotItSchema;\n\n        this.size = size;\n\n        const title = new PIXI.Text(\"Your Hand\", TextStyles.HEADING_1);\n        title.x = -Math.floor(title.width / 2);\n        title.y = -(Math.floor(this.size / 2) + 85);\n\n        this.cardsRemainingLabel = new PIXI.Text(\"\", TextStyles.HEADING_2);\n        this.cardsRemainingLabel.y = -(Math.floor(this.size / 2) + 40);\n\n        this.addChild(title);\n        this.addChild(this.cardsRemainingLabel);\n\n    }\n\n    drawNewCard(card: Card) {\n        if (this.curCard) {\n            this.removeChild(this.curCard);\n            this.curCard.destroy({children: true});\n        }\n\n        this.curCard = new CardContainer(this.size, card, this.isPlayer);\n        this.curCard.subscribeClick((cardSymbol: number) => {\n            this.playCardCallback(cardSymbol);\n        });\n        this.addChild(this.curCard);\n    }\n\n    updateCardsRemaining(numRemaining: number | null) {\n        if (numRemaining == null) {\n            this.cardsRemainingLabel.text = \"\";\n        } else {\n            this.cardsRemainingLabel.text = numRemaining + \" card\" + ((numRemaining === 1)? \"\": \"s\") + \" remaining\";\n            this.cardsRemainingLabel.x = -Math.floor(this.cardsRemainingLabel.width / 2);\n        }\n    }\n\n    // Game has ended and player is the winner\n    endGameAsWinner() {\n        this.curCard?.clear();\n        this.updateCardsRemaining(0);\n        this._unsubscribeFromPlayerDataChange();\n        MicManager.endTranscription();\n    }\n\n    // Game had ended, but player is not the winner\n    endGame() {\n        this.curCard?.disable()\n        this._unsubscribeFromPlayerDataChange();\n        MicManager.endTranscription();\n    }\n\n    prepareForGame(playerId: string, isPlayer: boolean) {\n        this.playerId = playerId;\n        this.isPlayer = isPlayer;\n\n        this._subscribeToPlayerDataChange();\n    }\n\n    reset() {\n        this.updateCardsRemaining(null);\n        if (this.curCard) {\n            this.removeChild(this.curCard);\n        }\n        this.curCard = null;\n    }\n\n    startGame() {\n        MicManager.beginTranscription(getTranscribeUrl(this.schema, this.playerId), this._handleWords);\n        \n        this.drawNewCard(getPlayerCardAtIndex(this.schema, this.playerId, 0));\n        this.updateCardsRemaining(getPlayerCardsRemaining(this.schema, this.playerId, 0));\n    }\n\n    _subscribeToPlayerDataChange() {\n        console.log(\"subscribe\");\n        this.schema.gameState.playerHandIndex.onChange = (curIndex, handPlayerId) => {\n            if (handPlayerId === this.playerId) {\n                this.drawNewCard(getPlayerCardAtIndex(this.schema, this.playerId, curIndex));\n                this.updateCardsRemaining(getPlayerCardsRemaining(this.schema, this.playerId, curIndex));\n            }\n        }\n\n        \n        this.schema.gameState.localTimeouts.onChange = this._onLocalTimeoutChange;\n    }\n\n    _onLocalTimeoutChange = (newFreeAfterTime: number, playerId: string) => {\n        if (playerId !== this.playerId) return;\n\n        const now = Date.now();\n\n        if (this.wrongPlayTimeout) {\n            clearTimeout(this.wrongPlayTimeout);\n            this.wrongPlayTimeout = null;\n            this.curCard?.hideError();\n        }\n\n        if (now < newFreeAfterTime) {\n            this.curCard?.showError();\n            this.wrongPlayTimeout = setTimeout(() => {\n                this.curCard?.hideError();\n                this.wrongPlayTimeout = null;\n            }, newFreeAfterTime - now);\n        }\n    }\n\n    _unsubscribeFromPlayerDataChange() {\n        console.log(\"unsubscribe\");\n        this.schema.gameState.playerHandIndex.onChange = () => {};\n        this.schema.gameState.localTimeouts.onChange = () => {};\n    }\n\n    private currentTransciptionResultId: string = \"\";\n    private hasSubmiitedForCurrentTranscription: boolean = false;\n\n    _handleWords = (transcriptionResult: TranscriptionResult) => {\n        console.log(\"_handleWords\", transcriptionResult.words.toString());\n        if (transcriptionResult.resultId !== this.currentTransciptionResultId) {\n            this.hasSubmiitedForCurrentTranscription = false;\n            this.currentTransciptionResultId = transcriptionResult.resultId;\n        }\n\n        // TODO: check can submit\n        if (!this.hasSubmiitedForCurrentTranscription) {\n            const candidateWords = getCandidateWords(this.schema, this.playerId);\n            console.log(\"candidateWords\", candidateWords);\n\n            const submittableWord = transcriptionResult.words.find(w => candidateWords.has(w));\n            console.log(\"submittableWord\", submittableWord);\n            \n            if (submittableWord) {\n                this.hasSubmiitedForCurrentTranscription = true;\n                const symbolId = getSymbolIdFromWord(submittableWord);\n                this.playCardCallback(symbolId);\n                console.log(\"playing\", submittableWord, symbolId)\n            }\n        }\n    }\n}","import * as PIXI from \"pixi.js\";\nimport { Scene } from \"./Scene\";\nimport * as GameActions from \"../models/GameActions\";\nimport { PlayerList } from \"../pixi/PlayerList\";\nimport { DeckContainer } from \"../pixi/DeckContainer\";\nimport { HandContainer } from \"../pixi/HandContainer\";\n\nimport { Button } from \"../pixi/Button\";\nimport { isHost, isPlayer, getHost } from \"../schemas/selectors/LobbySelectors\";\nimport { SubscriptionManager } from \"../schemas/SubscriptionManager\";\nimport { isWinner, getGamePhase, getWinnerName, getCenterCardIndex } from \"../schemas/selectors/GameSelectors\";\nimport { ButtonStyles, TextStyles } from \"../pixi/StyleConstants\";\n\nexport class GameScene extends Scene {\n    private toLobbyButton: Button = new Button(\"Back to lobby\", ButtonStyles.default, TextStyles.HEADING_2);\n    private getReadyLabel: PIXI.Text = new PIXI.Text(\"Get Ready!\", TextStyles.HEADING_1);\n    //@ts-ignore\n    private handContainer: HandContainer;\n    //@ts-ignore\n    private deckContainer: DeckContainer;\n\n    private effectivePlayerId: string = \"\";\n    \n    private gameInitialized: boolean = false;\n\n    init() {\n        const playerList = new PlayerList(this.room.sessionId, this.room);\n        playerList.x = 10;\n        playerList.y = 96;\n\n        this.addChild(playerList);\n\n        let cardSize = 370;\n        \n\n        const deckContainer = new DeckContainer(this.room.state, cardSize);\n        deckContainer.x = 415;\n        deckContainer.y = 370;\n        \n        const handContainer = new HandContainer(\n            this.room.state,\n            cardSize,\n            (symbol) => GameActions.selectSymbol(this.room, symbol, getCenterCardIndex(this.room.state))\n        );\n        \n        handContainer.x = 850;\n        handContainer.y = 370;\n\n        this.addChild(deckContainer);\n        this.addChild(handContainer);\n\n        this.toLobbyButton.x = 630;\n        this.toLobbyButton.y = 570;\n        this.toLobbyButton.onClick(this.backToLobby);\n\n        this.getReadyLabel.x = Math.floor(handContainer.x - (this.getReadyLabel.width/2));\n        this.getReadyLabel.y = Math.floor(handContainer.y - (this.getReadyLabel.height/2));\n\n        SubscriptionManager.subscribe(this.room.state, (changes) => {\n            changes.forEach(change => {\n                if (change.field === \"mode\") {\n                    if (change.value === \"lobby\") {\n                        this.removeChild(this.toLobbyButton);\n\n                        deckContainer.reset();\n                        handContainer.reset();\n                    }\n                }\n            });\n        })\n\n        SubscriptionManager.subscribe(this.room.state.gameState, (changes) => {\n            changes.forEach(change => {\n                if (change.field === \"phase\") {\n                    this.handleGamePhaseChange(change.value);\n                }\n            });\n        });\n\n        this.handContainer = handContainer;\n        this.deckContainer = deckContainer;\n\n        this.handleGamePhaseChange(getGamePhase(this.room.state));\n    }\n\n    backToLobby = () => {\n        GameActions.backToLobby(this.room);\n    }\n\n    initializeDecks() {\n        const isAPlayer = isPlayer(this.room.state, this.room.sessionId);\n        this.effectivePlayerId = isAPlayer ? this.room.sessionId : getHost(this.room.state);\n        this.deckContainer.prepareForGame();\n        this.handContainer.prepareForGame(this.effectivePlayerId, isAPlayer);\n        this.gameInitialized = true;\n    }\n\n    showHandLabel(text: string | null) {\n        if (text) {\n            this.getReadyLabel.text = text;\n            this.getReadyLabel.x = Math.floor(this.handContainer.x - (this.getReadyLabel.width / 2));\n        }\n        this.addChild(this.getReadyLabel);\n    }\n\n    handleGamePhaseChange(newGamePhase: string) {\n        switch(newGamePhase) {\n            case \"pregame\":\n                this.initializeDecks();\n                this.showHandLabel(\"Get Ready!\");\n                break;\n            case \"in_progress\":\n                if (!this.gameInitialized) {\n                    this.initializeDecks();\n                }\n                this.handContainer.startGame();\n                this.removeChild(this.getReadyLabel);\n                break;\n\n            case \"endgame\":\n                if (isWinner(this.room.state, this.effectivePlayerId)) {\n                    this.showHandLabel(\"You Win!\");\n                    this.handContainer.endGameAsWinner();\n                } else {\n                    const winningPlayer = getWinnerName(this.room.state);\n                    this.showHandLabel( `${winningPlayer} wins`);\n\n                    this.handContainer.endGame();\n                }\n\n                if (isHost(this.room.state, this.room.sessionId)) {\n                    this.addChild(this.toLobbyButton);\n                }\n                break;\n            default:\n                this.removeChild(this.getReadyLabel);\n                this.gameInitialized = false;\n                break;\n        }\n    }\n    \n}","import React, { useRef, useEffect, useState } from 'react';\nimport * as PIXI from \"pixi.js\";\nimport * as Colyseus from \"colyseus.js\";\nimport { DataChange } from \"@colyseus/schema\";\n\nimport './App.css';\nimport { JoinGameForm } from './components/JoinGameForm';\nimport { SpotItSchema } from './schemas/SpotItSchema';\nimport { SceneManager } from './scenes/SceneManager';\nimport { LobbyScene } from './scenes/LobbyScene';\nimport { GameScene } from './scenes/GameScene';\nimport { SubscriptionManager } from './schemas/SubscriptionManager';\nimport { TextStyles } from './pixi/StyleConstants';\n\nconst location = window.document.location;\n\nvar host = location.host.replace(/:.*/, '');\nlet endpoint = \"ws://localhost:2567\";\nif (host.indexOf(\"localhost\") < 0) {\n  endpoint = location.protocol.replace(\"http\", \"ws\") + \"//\" + host + (location.port ? ':' + location.port : '');\n}\n\nconst client = new Colyseus.Client(endpoint);\n\nfunction App() {\n  const gameContainer = useRef(null);\n  const [pixiReady, setPixiReady] = useState<boolean>(false);\n  const [pixiApp, setPixiApp] = useState<PIXI.Application>();\n  const [inRoom, setInRoom] = useState<boolean>(false);\n\n  useEffect(() => {\n    PIXI.Loader.shared\n        .add((window as any).__PUBLIC_URL__ + \"/assets/spritesheet.json\")\n        .load(() => {\n          const app = new PIXI.Application({ backgroundColor: 0xffffff, width: 1100, height: 630 });\n          if (gameContainer.current != null) {\n            // @ts-ignore\n            gameContainer.current.prepend(app.view);\n            setPixiApp(app);\n            setPixiReady(true);\n          }\n        });\n  }, []);\n\n  function joinRoom(roomName: string, name: string) {\n    client.joinOrCreate<SpotItSchema>(\"spot-it\", { roomName, name }).then((room: Colyseus.Room<SpotItSchema>) => {\n      \n      const app: PIXI.Application = pixiApp as PIXI.Application;\n\n      const sceneManager = new SceneManager(app);\n\n      sceneManager.addScene(\"lobby\", new LobbyScene(app, room));\n      sceneManager.addScene(\"game\", new GameScene(app, room));\n\n      const header = new PIXI.Text(`Room: ${roomName}`, TextStyles.HEADING_2);\n      header.x = 10;\n      header.y = 10;\n      app.stage.addChild(header);\n\n      SubscriptionManager.subscribe(room.state, (changes: DataChange[]) => {\n        changes.forEach(change => {\n          switch(change.field) {\n            case \"mode\": \n              if (change.value !== sceneManager.getCurrentScene()) {\n                sceneManager.switch(change.value);\n              }\n              break;\n          }\n        });\n      });\n      setInRoom(true);\n    });\n  }\n  \n  return (\n    <div className=\"App\">\n      <div id=\"joinGameForm\">\n        {pixiReady && !inRoom && <JoinGameForm handleSubmit={joinRoom} /> }\n      </div>\n      <div ref={gameContainer}></div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n      <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { EventStreamMarshaller, Message } from \"@aws-sdk/eventstream-marshaller\";\nimport * as util_utf8_node from \"@aws-sdk/util-utf8-node\"\nimport * as getUserMedia from \"get-user-media-promise\";\nimport MicrophoneStream from \"microphone-stream\";\n\nimport * as audioUtils from \"./AudioUtils\";\n\nexport type TranscriptionResult = {\n    words: string[],\n    resultId: string\n}\n\nlet micStream: MicrophoneStream;\nlet inputSampleRate: number;\nlet socket: WebSocket;\nlet sampleRate = 44100;\n\nconst eventStreamMarshaller = new EventStreamMarshaller(util_utf8_node.toUtf8, util_utf8_node.fromUtf8);\n\nconst streamAudioToWebSocket = function (userMediaStream: MediaStream, websocketUrl: string, callback: (r: TranscriptionResult) => void ) {\n    //let's get the mic input from the browser, via the microphone-stream module\n    if (micStream) {\n        micStream.playRecording();\n    } else {\n        micStream = new MicrophoneStream();\n        // @ts-ignore\n        micStream.on(\"format\", function(data) {\n            inputSampleRate = data.sampleRate;\n        });\n\n        micStream.setStream(userMediaStream);\n    }\n    \n\n    //open up our WebSocket connection\n    socket = new WebSocket(websocketUrl);\n    socket.binaryType = \"arraybuffer\";\n\n    // when we get audio data from the mic, send it to the WebSocket if possible\n    socket.onopen = function() {\n        // @ts-ignore\n        micStream.on('data', function(rawAudioChunk: any) {\n            // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n            let binary = convertAudioToBinaryMessage(rawAudioChunk);\n\n            if (socket.readyState === socket.OPEN) {\n                // @ts-ignore\n                socket.send(binary);\n            }\n                \n        }\n    )};\n\n    // handle messages, errors, and close events\n    wireSocketEvents(callback);\n}\n\nconst disconnectAudioAndWebsocket = () => {\n    stop(socket);\n}\n\nfunction convertAudioToBinaryMessage(audioChunk: any) {\n    let raw = MicrophoneStream.toRaw(audioChunk);\n\n    if (raw == null) {\n        return;\n    }\n\n    // downsample and convert the raw audio bytes to PCM\n    let downsampledBuffer = audioUtils.downsampleBuffer(raw, inputSampleRate, sampleRate);\n    let pcmEncodedBuffer = audioUtils.pcmEncode(downsampledBuffer);\n\n    // add the right JSON headers and structure to the message\n    let audioEventMessage: Message = getAudioEventMessage(Buffer.from(pcmEncodedBuffer));\n\n    //convert the JSON object + headers into a binary event stream message\n    let binary = eventStreamMarshaller.marshall(audioEventMessage);\n\n    return binary;\n}\n\n\nfunction wireSocketEvents(callback: (r: TranscriptionResult) => void) {\n    // handle inbound messages from Amazon Transcribe\n    socket.onmessage = function (message: MessageEvent) {\n        //convert the binary event stream message to JSON\n        let messageWrapper = eventStreamMarshaller.unmarshall(Buffer.from(message.data));\n        let messageBody = JSON.parse(String.fromCharCode.apply(String, messageWrapper.body as any));\n        if (messageWrapper.headers[\":message-type\"].value === \"event\") {\n            const result = handleEventStreamMessage(messageBody);\n            if (result) {\n                console.log(\"wireSocketEvents: callback\");\n                callback(result);\n            }\n        } else {\n            console.error(messageBody.Message);\n            stop(socket);\n        }\n    };\n\n    socket.onerror = function (e) {\n        console.error(\"socket error\", e);\n        stop(socket);\n    };\n    \n    socket.onclose = function (closeEvent) {\n        micStream.pauseRecording();\n        console.log('microphone paused');\n    };\n}\n\nconst stop = (socket: WebSocket) => {\n    if (socket) {\n        socket.close();\n        console.log('Transcription stopped');\n    }\n};\n\nfunction getAudioEventMessage(buffer: Buffer): Message {\n    // wrap the audio data in a JSON envelope\n    return {\n        headers: {\n            ':message-type': {\n                type: 'string',\n                value: 'event'\n            },\n            ':event-type': {\n                type: 'string',\n                value: 'AudioEvent'\n            }\n        },\n        body: buffer\n    };\n}\n\nconst handleEventStreamMessage = (messageJson: any): TranscriptionResult | null => {\n    const results = messageJson.Transcript.Results;\n    if (results.length > 0) {\n      if (results[0].Alternatives.length > 0) {\n        const transcript = decodeURIComponent(escape(results[0].Alternatives[0].Transcript));\n        return {\n            words: transcript.toLowerCase().replace('.', '').replace('?', '').replace('!', '').split(\" \"),\n            resultId:  results[0].ResultId\n        }\n      }\n    }\n    return null;\n};\n\n\n\nexport default class MicManager {\n    static stream: MediaStream;\n\n    static getPermission(): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            getUserMedia({video: false, audio: true})\n            .then((stream: MediaStream) => {\n                this.stream = stream;\n                resolve(true)\n            }).catch(function(error: any) {\n                switch(error.name) {\n                    case \"DevicesNotFoundError\":\n                    case \"NotFoundError\":\n                        alert(`No microphone device found. (${error.name})`);\n                        break;\n                    case \"NotAllowedError\":\n                    case \"PermissionDeniedError\":\n                        alert(`Permission rejected. (${error.name})`);\n                        break; \n                    default:\n                        alert(`Unknown error. (${error.name})`);\n                }\n                resolve(false);\n            });\n        })\n    }\n\n    static beginTranscription(websocketUrl: string, callback: (transcriptionResult: TranscriptionResult) => void) {\n        console.log(websocketUrl);\n        streamAudioToWebSocket(this.stream, websocketUrl, callback);\n    }\n\n    static endTranscription() {\n        disconnectAudioAndWebsocket();\n    }\n}","export function pcmEncode(input: any): ArrayBuffer {\n    let offset = 0;\n    let buffer = new ArrayBuffer(input.length * 2);\n    let view = new DataView(buffer);\n    for (let i = 0; i < input.length; i++, offset += 2) {\n        let s = Math.max(-1, Math.min(1, input[i]));\n        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n    }\n    return buffer;\n}\n\nexport function downsampleBuffer(buffer: any, inputSampleRate = 44100, outputSampleRate = 16000) {\n        \n    if (outputSampleRate === inputSampleRate) {\n        return buffer;\n    }\n\n    let sampleRateRatio = inputSampleRate / outputSampleRate;\n    let newLength = Math.round(buffer.length / sampleRateRatio);\n    let result = new Float32Array(newLength);\n    let offsetResult = 0;\n    let offsetBuffer = 0;\n    \n    while (offsetResult < result.length) {\n\n        let nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n\n        let accum = 0,\n        count = 0;\n        \n        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++ ) {\n            accum += buffer[i];\n            count++;\n        }\n\n        result[offsetResult] = accum / count;\n        offsetResult++;\n        offsetBuffer = nextOffsetBuffer;\n\n    }\n\n    return result;\n\n}"],"sourceRoot":""}